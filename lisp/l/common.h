static pointer CLO7139();
static pointer CLO7190();
static pointer CLO7368();
static pointer CLO7419();
static pointer CLO7833();
static pointer CLO9910();
static pointer CLO11012();
static pointer CLO11153();
static pointer CLO13194();
static pointer CLO15618();
static pointer CLO15739();
static pointer (*ftab[4])();

#define QUOTE_STRINGS_SIZE 531
static char *quote_strings[QUOTE_STRINGS_SIZE]={
    "\"EusLisp\"",
    "\"EusLisp ~A for ~A  created on ~A\"",
    "lisp-implementation-version",
    "*os-version*",
    "\"PROG1\"",
    "let",
    "progn",
    "\"LOOP\"",
    "block",
    "nil",
    "tagbody",
    "go",
    "when",
    "not",
    "while",
    "prog1",
    "car",
    "setf",
    "cdr",
    "cons",
    "#(:test :test-not :key)",
    "if",
    "member",
    ":test",
    ":test-not",
    ":key",
    "+",
    "1+",
    "setq",
    "-",
    "1-",
    "eql",
    "send",
    "quote",
    ":vtype",
    "1",
    "2",
    "boundp",
    ":global",
    ":special",
    ":constant",
    "\"DOTIMES\"",
    "0",
    "declare",
    "integer",
    "<",
    "\"DOLIST\"",
    "pop",
    "\"DOSYM\"",
    "*package*",
    "let*",
    "find-package",
    "0",
    "intsymvector",
    "length",
    "elt",
    "inc",
    "symbolp",
    "\"DOEXTSYM\"",
    "0",
    "symvector",
    "\"DOALLSYM\"",
    "dolist",
    "list-all-packages",
    "do-symbols",
    "\"PSETQ\"",
    "list",
    "\"DO\"",
    "return",
    "psetq",
    "\"DO*\"",
    "(t otherwise)",
    "eq",
    "memq",
    "\"CASE\"",
    "(t otherwise)",
    "derivedp",
    "or",
    "\"CCASE\"",
    "pname",
    "\"~d\"",
    "#(:test :test-not :key)",
    "identity",
    "#(:test :test-not :key)",
    "#(:test :test-not :key)",
    "#(:test :test-not :key)",
    "#(:test :test-not :key)",
    "#(:key :test :test-not)",
    "#(:key :test :test-not)",
    "#(:key :test :test-not)",
    "#(:start :end :test :test-not :key)",
    "#(:start :end :key)",
    "#(:start :end :key)",
    "#(:start :end :test :test-not :key)",
    "#(:start :end :key)",
    "#(:start :end :key)",
    "#(:start :end :test :test-not :key)",
    "#(:start :end :key)",
    "#(:start :end :key)",
    "#(:key)",
    "#(:key)",
    "#(:initial-element)",
    "\"integer required for length of make-list\"",
    "#(:initial-element)",
    "(cons list)",
    ":initial-element",
    ":element-type",
    "make-array",
    "#(:start :end)",
    "#(:start1 :end1 :start2 :end2)",
    "#(:start :end :test :test-not :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :test :test-not :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :test :test-not :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :test :test-not :count :key)",
    "#(:start :end :count :key)",
    "#(:start :end :count :key)",
    "#(:test :test-not :key :start :end)",
    "apply",
    "function",
    "send-message",
    "self",
    "class",
    "super",
    "\"INST\"",
    "instantiate",
    "\"INST\"",
    "send*",
    "defmethod",
    "metaclass-name",
    "#(:super :include :printer :constructor :predicate :copier :metaclass :element-type :size :slots :documentation)",
    "object",
    "metaclass",
    "vars",
    "types",
    "forwards",
    "\"duplicated object variable name\"",
    ":type",
    ":forward",
    "\"duplicated object variable name\"",
    "\"variable name expected for :slots\"",
    "vector",
    "((:bit . 1) (:char . 2) (:byte . 3) (:integer . 4) (:float . 5) (:foreign . 6))",
    "vectorclass",
    "name",
    "element-type",
    "size",
    "cix",
    "enter-class",
    ":class-documentation",
    "string",
    "\"-\"",
    "macro",
    "obj",
    "slot",
    "make-class",
    ":slots",
    "#(:slots :super :size :metaclass :element-type :documentation :doc)",
    ":super",
    ":metaclass",
    ":size",
    ":documentation",
    "readtable",
    "*readtable*",
    "*default-readtable*",
    "\"readtable expected\"",
    "*keyword-package*",
    "(lambda lambda-closure)",
    "compiled-code",
    "stream",
    ":input",
    "io-stream",
    ":output",
    "type",
    "case",
    "#(:start :end :from-end :initial-value)",
    "#(:key)",
    "putprop",
    "setf-update-fn",
    "remprop",
    "setf-lambda",
    "setf-method",
    "\"A doc-string expected.\"",
    "\"Extra arguments.\"",
    "setf-documentation",
    "list-length",
    "\"(store-variable) expected.\"",
    "lambda",
    "the",
    "structure-access",
    "system::structure-set",
    "(lambda)",
    "\"SETF?\"",
    "\"~S is an illegal SETF form.\"",
    "\"~S is an illegal SETF form.\"",
    "\"MULT\"",
    "\"MULT\"",
    "((0 first) (1 second) (2 third) (3 fourth) (4 fifth) (5 sixth) (6 seventh))",
    "\"LISP\"",
    "\"LISP\"",
    "\"no such package\"",
    "\"@(#)$Id: common.l,v 1.1.1.1 2003/11/20 07:46:30 eus Exp $\"",
    "(lisp-implementation-type lisp-implementation-version)",
    "(macroexpand prog1 loop unless until pop push pushnew inc dec incf decf)",
    "(defvar defparameter defconstant deflocal dotimes dolist do-symbols do-external-symbols do-all-symbols psetq do do* prog prog* case classcase otherwise string alias caaar caadr cadar cdaar cdadr cddar cdddr fourth fifth sixth seventh eighth cadddr cddddr cadddr caaddr cdaddr caddddr flatten list-insert list-delete adjoin union intersection set-difference set-exclusive-or rotate-list last copy-tree copy-list nreconc rassoc acons member assoc subsetp maplist mapcon)",
    "(find find-if find-if-not position position-if position-if-not count count-if count-if-not member-if member-if-not pairlis make-list make-sequence fill replace transpose-list remove remove-if remove-if-not delete delete-if delete-if-not substitute substitute-if substitute-if-not nsubstitute nsubstitute-if nsubstitute-if-not unique remove-duplicates extream send-super-lexpr send-lexpr send-super send-all resend send-super* send* instance instance* make-instance defclassmethod delete-method make-class defstruct defclass readtablep copy-readtable set-syntax-from-char collect-if collect-instances)",
    "(keywordp constantp functionp vector-class-p compiled-function-p input-stream-p output-stream-p io-stream-p special-form-p macro-function)",
    "(zerop plusp minusp oddp evenp /= logandc1 logandc2 ecase every some reduce merge-list merge expt signum defsetf define-setf-method setf multiple-value-bind multiple-value-setq pop push)",
    "(get-internal-run-time list-length values first second third bye)",
    "(rad2deg deg2rad)",
    "lisp-implementation-type",
    "\"nil\"",
    "\"nil\"",
    "euserror",
    "macroexpand",
    "\"(form)\"",
    "\"(&rest args)\"",
    "loop",
    "\"(&rest forms)\"",
    "unless",
    "\"(pred &rest form)\"",
    "until",
    "\"(condition &rest forms)\"",
    "\"(s)\"",
    "push",
    "\"(item place)\"",
    "pushnew",
    "\"(item place &key test test-not key)\"",
    "\"(var &optional h)\"",
    "dec",
    "\"(var &optional h)\"",
    "incf",
    "\"(var &optional h)\"",
    "decf",
    "\"(var &optional h)\"",
    "defvar",
    "\"(var &optional (init nil) (doc nil))\"",
    "deflocal",
    "\"(var &optional (init nil) (doc nil))\"",
    "defparameter",
    "\"(var init &optional (doc nil))\"",
    "defconstant",
    "\"(sym val &optional doc)\"",
    "dotimes",
    "\"(vars &rest forms)\"",
    "\"(vars &rest forms)\"",
    "\"(vars &rest forms)\"",
    "do-external-symbols",
    "\"(vars &rest forms)\"",
    "do-all-symbols",
    "\"(var &rest forms)\"",
    "\"(&rest varvals)\"",
    "do",
    "\"(vars endtest &rest body)\"",
    "do*",
    "\"(vars endtest &rest body)\"",
    "prog",
    "\"(vars &rest body)\"",
    "prog*",
    "\"(vars &rest body)\"",
    "casebody",
    "\"(body)\"",
    "casehead",
    "\"(keyvar head)\"",
    "case1",
    "\"(keyvar clauses)\"",
    "\"(key &rest clauses)\"",
    "classcasehead",
    "\"(keyvar head)\"",
    "classcase1",
    "\"(keyvar clauses)\"",
    "classcase",
    "\"(key &rest clauses)\"",
    "\"(x)\"",
    "alias",
    "\"(new old)\"",
    "values",
    "caaar",
    "\"(x)\"",
    "caadr",
    "\"(x)\"",
    "cadar",
    "\"(x)\"",
    "cdaar",
    "\"(x)\"",
    "cdadr",
    "\"(x)\"",
    "cddar",
    "\"(x)\"",
    "cdddr",
    "\"(x)\"",
    "first",
    "second",
    "cadr",
    "third",
    "caddr",
    "fourth",
    "\"(x)\"",
    "fifth",
    "\"(x)\"",
    "sixth",
    "\"(x)\"",
    "seventh",
    "\"(x)\"",
    "eighth",
    "\"(x)\"",
    "cddddr",
    "\"(x)\"",
    "cadddr",
    "\"(x)\"",
    "caaddr",
    "\"(x)\"",
    "cdaddr",
    "\"(x)\"",
    "caddddr",
    "\"(x)\"",
    "flatten",
    "\"(l &optional accumulator)\"",
    "list-insert",
    "\"insert item as the pos'th element in list.\nif pos is bigger than the length of list, item is nconc'ed at the tail\"",
    "list-delete",
    "\"(lst n) delete nth element of lst\"",
    "adjoin",
    "\"(item list &key (test #'eq) (test-not) (key #'identity))\"",
    "union",
    "\"(list1 list2 &key (test #'eq) (test-not) (key #'identity))\"",
    "intersection",
    "\"(list1 list2 &key (test #'eq) (test-not) (key #'identity))\"",
    "set-difference",
    "\"(list1 list2 &key (test #'eq) (test-not) (key #'identity))\"",
    "set-exclusive-or",
    "\"(list1 list2 &key (test #'eq) (test-not) (key #'identity))\"",
    "rotate-list",
    "\"(l)\"",
    "last",
    "\"(x)\"",
    "copy-tree",
    "\"(x)\"",
    "copy-list",
    "\"(x)\"",
    "nreconc",
    "\"(x y)\"",
    "rassoc",
    "\"(item alist)\"",
    "acons",
    "\"(key datum alist)\"",
    "\"(item list &key key test test-not)\"",
    "assoc",
    "\"(item alist &key key test test-not)\"",
    "subsetp",
    "\"(sub super &key key test test-not)\"",
    "maplist",
    "\"(func arg &rest more-args &aux result)\"",
    "mapcon",
    "\"(func arg &rest more-args &aux result)\"",
    "find",
    "\"(item seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (key #'identity))\"",
    "find-if",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "find-if-not",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "position",
    "\"(item seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (key #'identity))\"",
    "position-if",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "position-if-not",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "count",
    "\"(item seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (key #'identity))\"",
    "count-if",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "count-if-not",
    "\"(pred seq &key (start 0) (end (length seq)) (key #'identity))\"",
    "member-if",
    "\"(test list &key (key #'identity))\"",
    "member-if-not",
    "\"(test list &key (key #'identity))\"",
    "collect-if",
    "\"(func seq &aux r)\"",
    "collect-instances",
    "\"(klass list)\"",
    "pairlis",
    "\"(l1 l2 &optional alist)\"",
    "transpose-list",
    "\"(dlist)\"",
    "make-list",
    "\"(leng &key initial-element)\"",
    "make-sequence",
    "\"(type size &key initial-element)\"",
    "fill",
    "\"(seq item &key (start 0) (end (length seq)))\"",
    "replace",
    "\"(dest src &key (start1 0) (end1 (length dest)) (start2 0) (end2 (length src)))\"",
    "remove",
    "\"(item seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (count 1000000) (key #'identity))\"",
    "remove-if",
    "\"(pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "remove-if-not",
    "\"(pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "delete",
    "\"(item seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (count 1000000) (key #'identity))\"",
    "delete-if",
    "\"(pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "delete-if-not",
    "\"(pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "substitute",
    "\"(newitem olditem seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (count 1000000) (key #'identity))\"",
    "substitute-if",
    "\"(newitem pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "substitute-if-not",
    "\"(newitem pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "nsubstitute",
    "\"(newitem olditem seq &key (start 0) (end (length seq)) (test #'eq) (test-not nil) (count 1000000) (key #'identity))\"",
    "nsubstitute-if",
    "\"(newitem pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "nsubstitute-if-not",
    "\"(newitem pred seq &key (start 0) (end (length seq)) (count 1000000) (key #'identity))\"",
    "unique",
    "\"(l)\"",
    "remove-duplicates",
    "\"(seq &key (test #'eq) (test-not) (key #'identity) (start 0) (end 1000000))\"",
    "extream",
    "\"(seq test &optional (key #'identity))\"",
    "send-super-lexpr",
    "\"(selector &rest msgs)\"",
    "send-super*",
    "\"(&rest msgs)\"",
    "send-lexpr",
    "\"(target selector &rest msgs)\"",
    "\"(&rest msgs)\"",
    "send-super",
    "\"(selector &rest msgs)\"",
    "send-all",
    "\"(receivers &rest mesg)\"",
    "resend",
    "\"(obj mesg)\"",
    "instance",
    "\"(cls &rest message)\"",
    "instance*",
    "\"(cls &rest message)\"",
    "make-instance",
    "\"(klass &rest args)\"",
    "defclassmethod",
    "\"(classname &rest methods)\"",
    "delete-method",
    "\"(classobj methodname)\"",
    "\"(name &key (super object) (include object) (printer nil) (constructor nil) (predicate nil) (copier nil) ((:metaclass metaklass) nil) (element-type nil) (size -1) ((:slots varlist) nil) (documentation nil))\"",
    "defstruct",
    "\"(name &rest slots)\"",
    "defclass",
    "\"(name &key slots (super 'object) (size -1) ((:metaclass metaklass) nil) element-type documentation (doc documentation))\"",
    "readtablep",
    "\"(x)\"",
    "copy-readtable",
    "\"(&optional (from *readtable*) (to nil))\"",
    "set-syntax-from-char",
    "\"(to-char from-char &optional (to-readtable *readtable*) (from-readtable *default-readtable*))\"",
    "keywordp",
    "\"(sym)\"",
    "constantp",
    "\"(obj)\"",
    "functionp",
    "\"(obj)\"",
    "vector-class-p",
    "\"(p)\"",
    "compiled-function-p",
    "\"(x)\"",
    "input-stream-p",
    "\"(obj)\"",
    "output-stream-p",
    "\"(obj)\"",
    "io-stream-p",
    "\"(obj)\"",
    "special-form-p",
    "\"(s)\"",
    "macro-function",
    "\"(s)\"",
    "zerop",
    "\"(n)\"",
    "plusp",
    "\"(n)\"",
    "minusp",
    "\"(n)\"",
    "oddp",
    "\"(n)\"",
    "evenp",
    "\"(n)\"",
    "/=",
    "\"(n1 n2)\"",
    "logandc1",
    "\"(x y)\"",
    "logandc2",
    "\"(x y)\"",
    "ecase",
    "\"(&rest x)\"",
    "every",
    "\"(pred arg &rest more-args)\"",
    "some",
    "\"(pred arg &rest more-args &aux result)\"",
    "reduce",
    "\"(func seq &key (start 0) (end (length seq)) from-end initial-value)\"",
    "merge-list",
    "\"(list1 list2 pred key &aux result p1 e1 e2 pp1 pp2)\"",
    "merge",
    "\"(result-class seq1 seq2 pred &key (key #'identity))\"",
    "expt",
    "\"(a x)\"",
    "signum",
    "\"(x)\"",
    "rad2deg",
    "\"(rad)\"",
    "deg2rad",
    "\"(deg)\"",
    "defsetf",
    "\"(access-fn &rest rest)\"",
    "define-setf-method",
    "\"(access-fn &rest rest)\"",
    "setf-expand-1",
    "\"(place newvalue)\"",
    "setf-expand",
    "\"(l)\"",
    "\"(&rest rest)\"",
    "multiple-value-bind",
    "\"(vlist init &rest forms)\"",
    "multiple-value-setq",
    "\"(vlist form)\"",
  };
